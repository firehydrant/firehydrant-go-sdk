// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/firehydrant/firehydrant-go-sdk/internal/utils"
)

type CreateSignalsHeartbeatEndpointConfigurationAnnotations struct {
}

type CreateSignalsHeartbeatEndpointConfigurationLink struct {
	Href *string `json:"href,omitzero"`
	Text *string `json:"text,omitzero"`
}

func (c *CreateSignalsHeartbeatEndpointConfigurationLink) GetHref() *string {
	if c == nil {
		return nil
	}
	return c.Href
}

func (c *CreateSignalsHeartbeatEndpointConfigurationLink) GetText() *string {
	if c == nil {
		return nil
	}
	return c.Text
}

// CreateSignalsHeartbeatEndpointConfigurationTemplateSignal - Signal template to be used when generating alerts for missed heartbeats
type CreateSignalsHeartbeatEndpointConfigurationTemplateSignal struct {
	Body        *string                                                 `json:"body,omitzero"`
	Annotations *CreateSignalsHeartbeatEndpointConfigurationAnnotations `json:"annotations,omitzero"`
	Tags        []string                                                `json:"tags,omitzero"`
	Links       []CreateSignalsHeartbeatEndpointConfigurationLink       `json:"links,omitzero"`
}

func (c CreateSignalsHeartbeatEndpointConfigurationTemplateSignal) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateSignalsHeartbeatEndpointConfigurationTemplateSignal) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateSignalsHeartbeatEndpointConfigurationTemplateSignal) GetBody() *string {
	if c == nil {
		return nil
	}
	return c.Body
}

func (c *CreateSignalsHeartbeatEndpointConfigurationTemplateSignal) GetAnnotations() *CreateSignalsHeartbeatEndpointConfigurationAnnotations {
	if c == nil {
		return nil
	}
	return c.Annotations
}

func (c *CreateSignalsHeartbeatEndpointConfigurationTemplateSignal) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *CreateSignalsHeartbeatEndpointConfigurationTemplateSignal) GetLinks() []CreateSignalsHeartbeatEndpointConfigurationLink {
	if c == nil {
		return nil
	}
	return c.Links
}

// CreateSignalsHeartbeatEndpointConfigurationKind - Type of heartbeat endpoint (e.g. 'http')
type CreateSignalsHeartbeatEndpointConfigurationKind string

const (
	CreateSignalsHeartbeatEndpointConfigurationKindHTTP  CreateSignalsHeartbeatEndpointConfigurationKind = "http"
	CreateSignalsHeartbeatEndpointConfigurationKindEmail CreateSignalsHeartbeatEndpointConfigurationKind = "email"
)

func (e CreateSignalsHeartbeatEndpointConfigurationKind) ToPointer() *CreateSignalsHeartbeatEndpointConfigurationKind {
	return &e
}
func (e *CreateSignalsHeartbeatEndpointConfigurationKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "email":
		*e = CreateSignalsHeartbeatEndpointConfigurationKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateSignalsHeartbeatEndpointConfigurationKind: %v", v)
	}
}

// CreateSignalsHeartbeatEndpointConfiguration - Create a new heartbeat endpoint configuration for your organization
type CreateSignalsHeartbeatEndpointConfiguration struct {
	// Unique URL path segment for the heartbeat endpoint
	Slug string `json:"slug"`
	// Whether the endpoint is active
	Enabled bool `json:"enabled"`
	// Optional description of the endpoint's purpose
	Description *string `json:"description,omitzero"`
	// Time interval in which heartbeats are expected (minimum '5m', maximum '24h')
	ExpectInterval string `json:"expect_interval"`
	// Signal template to be used when generating alerts for missed heartbeats
	TemplateSignal CreateSignalsHeartbeatEndpointConfigurationTemplateSignal `json:"template_signal"`
	// Type of heartbeat endpoint (e.g. 'http')
	Kind CreateSignalsHeartbeatEndpointConfigurationKind `json:"kind"`
	// HTTP methods allowed for this endpoint
	AllowedHTTPMethods []string `json:"allowed_http_methods,omitzero"`
	// User agent substring that must be present in requests
	AllowedUserAgentSubstring *string `json:"allowed_user_agent_substring,omitzero"`
	// Email addresses allowed to send heartbeats
	AllowedEmailSenders []string `json:"allowed_email_senders,omitzero"`
}

func (c CreateSignalsHeartbeatEndpointConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetSlug() string {
	if c == nil {
		return ""
	}
	return c.Slug
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetEnabled() bool {
	if c == nil {
		return false
	}
	return c.Enabled
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetExpectInterval() string {
	if c == nil {
		return ""
	}
	return c.ExpectInterval
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetTemplateSignal() CreateSignalsHeartbeatEndpointConfigurationTemplateSignal {
	if c == nil {
		return CreateSignalsHeartbeatEndpointConfigurationTemplateSignal{}
	}
	return c.TemplateSignal
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetKind() CreateSignalsHeartbeatEndpointConfigurationKind {
	if c == nil {
		return CreateSignalsHeartbeatEndpointConfigurationKind("")
	}
	return c.Kind
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetAllowedHTTPMethods() []string {
	if c == nil {
		return nil
	}
	return c.AllowedHTTPMethods
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetAllowedUserAgentSubstring() *string {
	if c == nil {
		return nil
	}
	return c.AllowedUserAgentSubstring
}

func (c *CreateSignalsHeartbeatEndpointConfiguration) GetAllowedEmailSenders() []string {
	if c == nil {
		return nil
	}
	return c.AllowedEmailSenders
}
